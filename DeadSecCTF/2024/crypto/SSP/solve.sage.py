

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_100 = Integer(100)
from pwn import *

from itertools import combinations
from tqdm import tqdm
from Crypto.Util.number import *

def solve_subset(arr_, s, brute):
    for arr in tqdm(combinations(arr_, len(arr_) - brute)):
        N = ceil(sqrt(len(arr)) / _sage_const_2 )
        M = identity_matrix(QQ, len(arr))
        M = M.augment(N*vector(arr))
        M = M.stack(vector([-_sage_const_1 /_sage_const_2  for _ in range(len(arr))] + [-N*s]))

        for row in M.LLL():
            for row in (row, -row):
                kk = [i+_sage_const_1 /_sage_const_2  for i in row][:-_sage_const_1 ]
                if not all([i in (_sage_const_0 , _sage_const_1 ) for i in kk]):
                    continue
                subset = [xx for xx, k in zip(arr, kk) if k]
                if sum(subset) == s:
                    return subset


def is_subset_sum(set, target):
    n = len(set)
    subset = [False] * n

    def backtrack(index, current_sum):
        if current_sum == target:
            return True
        if current_sum > target or index == n:
            return False

        # Include the current element in the subset
        subset[index] = True
        if backtrack(index + _sage_const_1 , current_sum + set[index]):
            return True

        # Exclude the current element from the subset
        subset[index] = False
        if backtrack(index + _sage_const_1 , current_sum):
            return True

        return False

    if backtrack(_sage_const_0 , _sage_const_0 ):
        # Subset with the target sum exists, print the subset
        result = [set[i] for i in range(n) if subset[i]]
        return result
    else:
        return None



io = remote("35.238.116.121", "32581")

for turn in range(_sage_const_100 ):
    io.recvuntil(f"Stage {turn+_sage_const_1 }\n")
    data = io.recvline().rstrip().decode().split()
    arr = data[:-_sage_const_1 ]
    s = data[-_sage_const_1 ]
    arr = [int(i) for i in arr]
    s = int(s)
    brute = _sage_const_1  # lmao
    if turn == _sage_const_0 :
        io.sendline(b'0')
        continue
    subset = solve_subset(arr, s, brute)
    if subset == None:
        subset = is_subset_sum(arr, s)
    print(subset)
    res = []
    for i in subset:
        res.append(str(arr.index(i)))
    io.sendline(f"{' '.join(res)}")

io.interactive()

