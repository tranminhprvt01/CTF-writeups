from Crypto.Util.number import *
from math import isqrt



def nextPrime(n):
    while not isPrime(n := n + 1):
        continue
    return n

n=200697881793620389197751143658858424075492240536004468937396825699483210280999214674828938407830171522000573896259413231953182108686782019862906633259090814783111593304404356927145683840948437835426703183742322171552269964159917779
e=65537
c=77163248552037496974551155836778067107086838375316358094323022740486805320709021643760063197513767812819672431278113945221579920669369599456818771428377647053211504958874209832487794913919451387978942636428157218259130156026601708
r=30736331670163278077316573297195977299089049174626053101058657011068283335270


c1 = nextPrime(r)


print(c1)



def solve(a, b, c):
    denta = b*b-4*a*c
    denta = isqrt(denta)
    x1 = (-b-denta)//(2*a)
    x2 = (-b+denta)//(2*a)
    return x1, x2



for b in range(1000):
    q1, q2 = solve(c1 + r, b*r, -n)
    if GCD(q1, n) == q1:
        q = q1
        print("Found 1")
        break
    elif GCD(q2, n) == q2:
        q = q2
        print("Found 2")
        break


p = n//q

assert p*q == n

d = inverse(e, (p-1)*(q-1))
print(long_to_bytes(pow(c, d, n)))


