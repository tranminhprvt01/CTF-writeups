from pwn import *
from Crypto.Cipher import AES

messages = \
[
    b"Hey Bob, just wanted to confirm that we're all set up and secure on the protocol. Everything looks good on my end - seeing the handshake complete and all the right signals!",
    b"Perfect, Alice. Same here, no issues at all. The encryption layers seem to be working flawlessly, and I've got authentication on my end verified. Nice and smooth.",
    b"Good to hear! It's refreshing to have something that's both quick and secure. Remember last time we were dealing with those laggy verifications? Nightmare!",
    b"Oh, don't remind me! This setup is like a dream by comparison. Plus, no random dropouts or mismatches so far, which is huge. Any initial thoughts on how it's handling under lol",
    b"Actually, I did a quick test, and it's holding up impressively well. Even with some extra simulated traffic, everything stayed stable. I think we're good to start scaling soon,",
    b"That's awesome news! Let's monitor it for a bit longer, but I have a feeling this might finally be the solution we've been waiting for. Thanks for all your setup work, Alice!"
]

m0 = messages[0]
m1 = messages[1]

io = remote("conversationalist.ctf.intigriti.io", 1349)



io.recvuntil(b'Conversation:\n')
cts = []
for i in range(6):
    io.recvuntil(b'< ')
    cts.append(io.recvline().rstrip().decode())



ct0 = cts[0].split(":")
aad0 = bytes.fromhex(ct0[0][:40])
tag0 = bytes.fromhex(ct0[0][40:])
ct0 = bytes.fromhex(ct0[1])
ct1 = cts[1].split(":")
aad1 = bytes.fromhex(ct1[0][:40])
tag1 = bytes.fromhex(ct1[0][40:])
ct1 = bytes.fromhex(ct1[1])




from sage.all import GF

x = GF(2)["x"].gen()
gf2e = GF(2 ** 128, name="y", modulus=x ** 128 + x ** 7 + x ** 2 + x + 1)


# Converts an integer to a gf2e element, little endian.
def _to_gf2e(n):
    return gf2e([(n >> i) & 1 for i in range(127, -1, -1)])


# Converts a gf2e element to an integer, little endian.
def _from_gf2e(p):
    n = p.integer_representation()
    ans = 0
    for i in range(128):
        ans <<= 1
        ans |= ((n >> i) & 1)

    return ans


# Calculates the GHASH polynomial.
def _ghash(h, a, c):
    la = len(a)
    lc = len(c)
    p = gf2e(0)
    for i in range(la // 16):
        p += _to_gf2e(int.from_bytes(a[16 * i:16 * (i + 1)], byteorder="big"))
        p *= h

    if la % 16 != 0:
        p += _to_gf2e(int.from_bytes(a[-(la % 16):] + bytes(16 - la % 16), byteorder="big"))
        p *= h

    for i in range(lc // 16):
        p += _to_gf2e(int.from_bytes(c[16 * i:16 * (i + 1)], byteorder="big"))
        p *= h

    if lc % 16 != 0:
        p += _to_gf2e(int.from_bytes(c[-(lc % 16):] + bytes(16 - lc % 16), byteorder="big"))
        p *= h

    p += _to_gf2e(((8 * la) << 64) | (8 * lc))
    p *= h
    return p


def recover_possible_auth_keys(a1, c1, t1, a2, c2, t2):
    """
    Recovers possible authentication keys from two messages encrypted with the same authentication key.
    More information: Joux A., "Authentication Failures in NIST version of GCM"
    :param a1: the associated data of the first message (bytes)
    :param c1: the ciphertext of the first message (bytes)
    :param t1: the authentication tag of the first message (bytes)
    :param a2: the associated data of the second message (bytes)
    :param c2: the ciphertext of the second message (bytes)
    :param t2: the authentication tag of the second message (bytes)
    :return: a generator generating possible authentication keys (gf2e element)
    """
    h = gf2e["h"].gen()
    p1 = _ghash(h, a1, c1) + _to_gf2e(int.from_bytes(t1, byteorder="big"))
    p2 = _ghash(h, a2, c2) + _to_gf2e(int.from_bytes(t2, byteorder="big"))
    for h, _ in (p1 + p2).roots():
        yield h


def forge_tag(h, a, c, t, target_a, target_c):
    """
    Forges an authentication tag for a target message given a message with a known tag.
    This method is best used with the authentication keys generated by the recover_possible_auth_keys method.
    More information: Joux A., "Authentication Failures in NIST version of GCM"
    :param h: the authentication key to use (gf2e element)
    :param a: the associated data of the message with the known tag (bytes)
    :param c: the ciphertext of the message with the known tag (bytes)
    :param t: the known authentication tag (bytes)
    :param target_a: the target associated data (bytes)
    :param target_c: the target ciphertext (bytes)
    :return: the forged authentication tag (bytes)
    """
    ghash = _from_gf2e(_ghash(h, a, c))
    target_ghash = _from_gf2e(_ghash(h, target_a, target_c))

    return (ghash ^ int.from_bytes(t, byteorder="big") ^ target_ghash).to_bytes(16, byteorder="big")



xor = lambda msg1, msg2: bytes([m1^m2 for m1,m2 in zip(msg1, msg2)])


ks = xor(m0, ct0)

target = b'Give me the flag'
target_c = xor(target, ks)
target_aad = aad0[:12] + len(target).to_bytes(8, 'big')



cnt=0
for h in recover_possible_auth_keys(aad0, ct0, tag0, aad1, ct1, tag1):
    cnt+=1
    print(h)
    target_t = forge_tag(h, aad0, ct0, tag0, target_aad, target_c)

    print(target_c.hex())
    print(target_t.hex())
    print((target_aad+target_t).hex() + ":" + target_c.hex())
    payload = (target_aad+target_t).hex() + ":" + target_c.hex()

    io.recvuntil(b'Join in on the conversation! Make sure your message is encrypted and uses the same format.\n')
    io.sendlineafter(b'> ', payload)

    io.recvuntil(b'< ')
    flag_ct = io.recvline().rstrip().decode()
    flag = flag_ct.split(":")
    flag = xor(ks, bytes.fromhex(flag[1]))
    print(flag)



    io.interactive()


# INTIGRITI{Coc0OnV3rS4tI0n5_Ar3-wH4t_Y0u'R3_h4V1nG,_1t'5-c4Ll3D_NuMB3r_US3d_0nC3_F0r_4_R34s0n!}


# from Crypto.Cipher import AES
# import os
# from random import randbytes




# key = bytes.fromhex("d7797ea5c434720f10a82c1970a17d642937e9d501b80a7738f2c60a1e84230a")
# nonce = bytes.fromhex("c861c5f3e3d85048ea3c53cf")



# messages = \
# [
#     b"Hi there, welcome to the challenge! I hope you have fun and learn something new.",
#     b"Good to know: the messages inside of this file will be *different on remote*."
# ]


# m1 = messages[0]
# m2 = messages[1]

# aad1 = nonce + len(m1).to_bytes(8, 'big')
# aad2 = nonce + len(m2).to_bytes(8, 'big')

# cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
# cipher.update(aad1)
# ct1, tag1 = cipher.encrypt_and_digest(m1)

# cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
# cipher.update(aad2)
# ct2, tag2 = cipher.encrypt_and_digest(m2)


# ks = xor(m1, ct1)









# """
# key = randbytes(32)
# iv = randbytes(12)

# aes = AES.new(key, AES.MODE_GCM, nonce=iv)
# a1 = randbytes(16)
# p1 = randbytes(16)
# aes.update(a1)
# c1, t1 = aes.encrypt_and_digest(p1)
# aes = AES.new(key, AES.MODE_GCM, nonce=iv)
# a2 = randbytes(16)
# p2 = randbytes(16)
# aes.update(a2)
# c2, t2 = aes.encrypt_and_digest(p2)

# for h in recover_possible_auth_keys(a1, c1, t1, a2, c2, t2):
#     print(h)
#     a = randbytes(16)
#     c = randbytes(16)
#     t = forge_tag(h, a1, c1, t1, a, c)

#     aes = AES.new(key, AES.MODE_GCM, nonce=iv)
#     aes.update(a)
#     print(aes.decrypt_and_verify(c, t))

# """







