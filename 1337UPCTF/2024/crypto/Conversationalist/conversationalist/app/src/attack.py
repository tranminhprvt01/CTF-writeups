from sage.all import GF

x = GF(2)["x"].gen()
gf2e = GF(2 ** 128, name="y", modulus=x ** 128 + x ** 7 + x ** 2 + x + 1)


# Converts an integer to a gf2e element, little endian.
def _to_gf2e(n):
    return gf2e([(n >> i) & 1 for i in range(127, -1, -1)])


# Converts a gf2e element to an integer, little endian.
def _from_gf2e(p):
    n = p.integer_representation()
    ans = 0
    for i in range(128):
        ans <<= 1
        ans |= ((n >> i) & 1)

    return ans


# Calculates the GHASH polynomial.
def _ghash(h, a, c):
    la = len(a)
    lc = len(c)
    p = gf2e(0)
    for i in range(la // 16):
        p += _to_gf2e(int.from_bytes(a[16 * i:16 * (i + 1)], byteorder="big"))
        p *= h

    if la % 16 != 0:
        p += _to_gf2e(int.from_bytes(a[-(la % 16):] + bytes(16 - la % 16), byteorder="big"))
        p *= h

    for i in range(lc // 16):
        p += _to_gf2e(int.from_bytes(c[16 * i:16 * (i + 1)], byteorder="big"))
        p *= h

    if lc % 16 != 0:
        p += _to_gf2e(int.from_bytes(c[-(lc % 16):] + bytes(16 - lc % 16), byteorder="big"))
        p *= h

    p += _to_gf2e(((8 * la) << 64) | (8 * lc))
    p *= h
    return p


def recover_possible_auth_keys(a1, c1, t1, a2, c2, t2):
    """
    Recovers possible authentication keys from two messages encrypted with the same authentication key.
    More information: Joux A., "Authentication Failures in NIST version of GCM"
    :param a1: the associated data of the first message (bytes)
    :param c1: the ciphertext of the first message (bytes)
    :param t1: the authentication tag of the first message (bytes)
    :param a2: the associated data of the second message (bytes)
    :param c2: the ciphertext of the second message (bytes)
    :param t2: the authentication tag of the second message (bytes)
    :return: a generator generating possible authentication keys (gf2e element)
    """
    h = gf2e["h"].gen()
    p1 = _ghash(h, a1, c1) + _to_gf2e(int.from_bytes(t1, byteorder="big"))
    p2 = _ghash(h, a2, c2) + _to_gf2e(int.from_bytes(t2, byteorder="big"))
    for h, _ in (p1 + p2).roots():
        yield h


def forge_tag(h, a, c, t, target_a, target_c):
    """
    Forges an authentication tag for a target message given a message with a known tag.
    This method is best used with the authentication keys generated by the recover_possible_auth_keys method.
    More information: Joux A., "Authentication Failures in NIST version of GCM"
    :param h: the authentication key to use (gf2e element)
    :param a: the associated data of the message with the known tag (bytes)
    :param c: the ciphertext of the message with the known tag (bytes)
    :param t: the known authentication tag (bytes)
    :param target_a: the target associated data (bytes)
    :param target_c: the target ciphertext (bytes)
    :return: the forged authentication tag (bytes)
    """
    ghash = _from_gf2e(_ghash(h, a, c))
    target_ghash = _from_gf2e(_ghash(h, target_a, target_c))

    return (ghash ^ int.from_bytes(t, byteorder="big") ^ target_ghash).to_bytes(16, byteorder="big")



xor = lambda msg1, msg2: bytes([m1^m2 for m1,m2 in zip(msg1, msg2)])

# m1 = b"Hey Bob, just wanted to confirm that we're all set up and secure on the protocol. Everything looks good on my end - seeing the handshake complete and all the right signals!"
# m2 = b"Perfect, Alice. Same here, no issues at all. The encryption layers seem to be working flawlessly, and I've got authentication on my end verified. Nice and smooth."

# ct1 = "b8fe82d61871f3499ae8867500000000000000acb9703cd9207bdac9a13d336ba03ce530:7b13e76abc320b52b9a618e0deb4e106340c3a395c936937e60b9c26157b2d4c8f21e10246da8cfe245aae4bf725d188ab77634f494ed692ae1989edcc8cad361f954aee933d9ce5d13122c20bb82825cad9ede20596e9234a54cfc3be0e6c0e055d1a12fab5deca13609789e372d5441d3db9a4fd7ab40e617802edbf368817c928dfe1643a2236f6da3e6f9ec1466553f6a98888aa75ee865d4a35824ffcfa636b8be8f49007efd030efd0"\
# .split(":")
# aad1 = bytes.fromhex(ct1[0][:40])
# tag1 = bytes.fromhex(ct1[0][40:])
# ct1 = bytes.fromhex(ct1[1])
# print(ct1, len(ct1))
# print(tag1)

# ct2 = "b8fe82d61871f3499ae8867500000000000000a234054c0556d785446240333b54f60525:6313ec2c9b3e1d52b98d01fac9f1b847091932385c8f6365e048d22e1329291f883ce50546cc9df93753e204bb1d999eee662d594b17c788a35694a8c398a6364d8904bd823094e5d52c6dd401fb30269692c1fa07c4f63b434acdc1ed116f18420e5b1bf1faf3cd0a6b9783f526904b0c69fce1e06bb8046e6b4bf6b973c711882bc2b269352d73a0dc236b88c4467518f6868f8fef34e384191e2e8a00e1e76c2d"\
# .split(":")
# aad2 = bytes.fromhex(ct2[0][:40])
# tag2 = bytes.fromhex(ct2[0][40:])
# ct2 = bytes.fromhex(ct2[1])
# print(ct2, len(ct2))
# print(tag2)



from Crypto.Cipher import AES
import os
from random import randbytes




key = bytes.fromhex("d7797ea5c434720f10a82c1970a17d642937e9d501b80a7738f2c60a1e84230a")
nonce = bytes.fromhex("c861c5f3e3d85048ea3c53cf")



messages = \
[
    b"Hi there, welcome to the challenge! I hope you have fun and learn something new.",
    b"Good to know: the messages inside of this file will be *different on remote*."
]


m1 = messages[0]
m2 = messages[1]

aad1 = nonce + len(m1).to_bytes(8, 'big')
aad2 = nonce + len(m2).to_bytes(8, 'big')

cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
cipher.update(aad1)
ct1, tag1 = cipher.encrypt_and_digest(m1)

cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
cipher.update(aad2)
ct2, tag2 = cipher.encrypt_and_digest(m2)


ks = xor(m1, ct1)


cnt=0
for h in recover_possible_auth_keys(aad1, ct1, tag1, aad2, ct2, tag2):
    cnt+=1
    print(h)
    a = aad1[:12] + (16).to_bytes(8, 'big')
    c = xor(b'Give me the flag', ks)
    # a = os.urandom(16)
    # c = os.urandom(16)
    t = forge_tag(h, aad1, ct1, tag1, a, c)

    print(c.hex())
    print(t.hex())
    print((a+t).hex() + ":" + c.hex())
    try:
        cipher = AES.new(key, AES.MODE_GCM, nonce)
        cipher.update(a)
        print(cipher.decrypt_and_verify(c, t))
        print(cnt, "wut do heo")
    except:
        continue






"""
key = randbytes(32)
iv = randbytes(12)

aes = AES.new(key, AES.MODE_GCM, nonce=iv)
a1 = randbytes(16)
p1 = randbytes(16)
aes.update(a1)
c1, t1 = aes.encrypt_and_digest(p1)
aes = AES.new(key, AES.MODE_GCM, nonce=iv)
a2 = randbytes(16)
p2 = randbytes(16)
aes.update(a2)
c2, t2 = aes.encrypt_and_digest(p2)

for h in recover_possible_auth_keys(a1, c1, t1, a2, c2, t2):
    print(h)
    a = randbytes(16)
    c = randbytes(16)
    t = forge_tag(h, a1, c1, t1, a, c)

    aes = AES.new(key, AES.MODE_GCM, nonce=iv)
    aes.update(a)
    print(aes.decrypt_and_verify(c, t))

"""





